# 算法题
需求描述：

假如要做一个字典应用，希望用户在输入字母的时候，自动给出前缀匹配的词。例如：

当用户输入：
sma

给出建议单词：
sma
smaak
smack
smaik
small
smalm
smalt
smarm
smart
……

要求一：
给出的单词按匹配度排序，所谓匹配度简单说就是，短的排前面长的排后面，如上例所示。

要求二：
给出的建议单词个数 N 可配置，当字典中的单词数小于 N 时，有多少返回多少。大于 N 时则返回 N 个。

字典在此：
https://raw.githubusercontent.com/words/an-array-of-english-words/master/words.json

压缩信息:
a、aah、aaha 3.4M
a$ah$a$ 1M

哈夫曼编码树 Huffman Tree

## Trie树和其它数据结构的比较

### Trie树与二叉搜索树

二叉搜索树应该是我们最早接触的树机构，我们知道，数据规模为n时，二叉搜索插入、查找、删除操作的时间复杂度通常只有O(log n),最坏的情况下整棵树所有的节点都只有一个子节点，退变成一个线性表，此时插入，查找、删除操作的时间复杂度是O(n)

通常情况下，Trie树的高度n要远大于搜索字符串的长度m，故查找操作的时间复杂度通常为O(m),最坏情况下的时间复杂度才为O(n),很容易看出，Trie树最坏情况下的查找也快过二叉搜索树。

文中Trie树都是拿字符串举例，其实它本身对key的适宜性是有严格要求的，如果key是浮点数的话，就可能导致整个Trie树巨长无比，节点可读性也非常差，这种情况下是不适宜用Trie树来保存数据的；而二叉搜索树就不存在这个问题。

### Trie树与Hash表

考虑一下Hash冲突的问题，Hash表通常我们说的复杂度是O(1),其实严格说起来这是接近完美的Hash表的复杂度，另外还需要考虑到hash函数本身需要遍历搜索字符串，复杂度是O(m).在不同键被映射到同一个位置（考虑cloased hashing，这同一个位置可以由一个普通链表来取代）的时候，需要进行查找的复杂度取决于这通一个位置下节点的数目，因此，在最坏情况下，Hash表也是可以成为一张单向链表的。

Trie树可以比较方便地按照key的字母序来排序（整棵树先序遍历一次就好），这跟绝大多数Hash表示不同的（Hash表一般对于不同的key来说是无序的）

在较理想的情况下，Hash表可以以O(1)的速度循序命中目标，如果这张表非常大，需要放到磁盘上的话，Hash表的查找访问在理想情况下只需要一次即可；但是Trie树访问磁盘的数目需要等于节点深度

很多时候Trie树比Hash表需要更多的空间，我们考虑这种一个节点存放一个字符的情况的话，在保存一个字符串的时候，没有办法吧它保存成一个单独的块。Trie树的节点压缩可以明显缓解这个问题

### Trie树的改进
#### 按位Trie树（Bitwise Trie）

原理上和普通Trie树差不多，只不过普通Trie树存储的最小单位是字符，但是Bitwise Trie存放的是位而已，这数据的存取由CPU指令一次直接实现，对于二进制数据，它理论上要比普通Trie树快。

#### 节点压缩

分支压缩：对于稳定的Trie树，基本上都是查找和读取操作，完全可以把一些分支进行压缩。例如，前图中最右侧分支的inn可以直接压缩成一个节点’inn‘，而不需要作为一棵常规的子树存在。Radix树就是根据这个原理来解决Trie树过深问题的。

节点映射表：这种方式也是在Trie树的节点可以已经几乎完全确定的情况下采用的，针对Trie树种节点的每一个状态，如果状态总数重复很多的话，通过一个元素为数字的多维数组（比如Triple Array Trie）来表示，这样存储Trie树本身的空间开销会小一些，虽说引入了一张额外的映射表

### 前缀树的应用
1.字符串的快速检索
字典树的查询时间复杂度O(logL),L是字符串的长度，所以效率还是比较高的。字典树的效率比hash表高。

2.字符串排序
从上图我们很容易看出单词的排序，先遍历字母序在前面，减少了没必要的公共子串

3.最长公共前缀
inn和int的最长公共前缀是in，遍历字典树到字母n时，此时这些单词的公共前缀是in。

4.自动匹配前缀显示后缀
我们使用词典或者是搜索引擎的时候，输入appl，后面会自动显示一堆前缀是appl的东东吧，那么有可能是通过字典树实现的，前面也说了字典树可以找到公共前缀，我们只需要把剩余的后缀遍历显示出来即可。

# `2 + 4 * 3 - 5 * 2`
eval

